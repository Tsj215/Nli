---
title: JavaScript中作用域的理解
date: 2020-08-20 16:04:40
tags: JavaScript
category: 文章
---

### 前言

在我们讨论作用域之前先抛出几个概念方便我们更好的理解之后的问题。`JavaScript` 作为一门动态语言，在任何的 `JavaScirpt` 代码执行之前都会先进行 **编译**。那么在编译的时候都发生了些什么呢？

**编译** 分为以下三个步骤

1. 分词/词法分析
   分词通俗上理解就是将一段字符组成的字符串分解成一个个的词法单元，例如 `var a = 1` 将被分解成 `var、a、=、1`，注意空格是否会被分解成词法单元这取决于空格在这门语言中是否有意义
2. 解析/语法分析
   在这个过程当中由词法单元组成的数组会被转换成抽象语法树（Abstract Syntax Tree, AST），什么是抽象语法树这里就不做过多介绍了
3. 代码生成
   在代码生成的步骤中会将解析出的 AST 转换为可执行的代码。

---

### 关于作用域首先提出几个问题

1. 什么是作用域
2. 作用域由什么用处

---

#### 什么是作用域

在我们编码的时候免不了会声明各种变量，并在之后找到再对其进行一些修改，那么我们声明的这些变量都储存在了哪里呢，我们又是通过什么去找到我们之前声明过的变量并进行相应的修改的呢？有问题就必然有与之对应的解决办法，而作用域的出现就很好地解决了以上的问题，那么作用域到底是什么呢，既然作用域的出现能够很好地解决这些问题，我们是不是能这样理解：**作用域** 就是一套设计十分严格的用来储存变量并在之后能够方便并快速找到这些变量的规则。

#### 作用域有什么用处

通过对上面问题的分析我们不难得出我们可以通过作用域来储存我们所声明的变量，并方便我们之后去查询之前所声明的变量，由此作用域的用处显而易见。

### 从编译器的角度理解作用域

#### 变量提升机制

相信对 JS 有一定了解的都听说过变量提升机制

```js
var a = 1;
```

还是这段代码，通过上面的概念不难得出首先编译器开始对这段代码进行编译，编译器首先便会去作用域中寻找是否存在一个名为 `a` 的变量，如果作用域中并不存在 `a` 则在当前作用域中声明一个新的变量并命名为 `a`，若是当前作用域已经存在 `a` 了则会忽略该声明继续下面的编译；当代码运行时，引擎便会去作用域中查找名为 `a` 的变量，若是存在 `a` 变量便会将 `2` 赋值给 `a`，若不存在便会抛出异常；通过总结我们可以得出变量的声明与赋值是分开进行的，在代码编译的过程中首先便会对所有未声明的变量进行声明操作，等到代码被执行的时候才会进行赋值操作，也正是这个原因才会有 Js 变量提升的机制

#### 变量查询的方法

现在我们知道所有的变量都是储存在了作用域中，但我们如何从作用域中查询我们所需要的变量呢？ 在引擎执行代码时会在作用域中查找变量是否被声明，但是引擎查找的方式会影响最终查找的结果，看下面的例子

```js
var a = b + 1;
```

引擎在执行上面这段代码的时候会对 `a` 进行 LHS 查询 而对 `b` 进行 RHS 查询，就现在为止我们可以简单地理解 LHS 和 RHS 分别为左查询和右查询，这个左右当然不是通过变量的顺序进行判断的，而是判断变量是处在赋值符的左侧还是右侧；现在我们再仔细地理解上面的代码，语义上为声明一个变量并命名为 `a` 然后将 `b + 1` 赋值给 `a`；当引擎去作用域中查询 `a` 时并不是去查询 `a` 的值而是去查询 `a` 这个变量本身，而引擎对 `b` 进行查询时却是查询 `b` 的值并 + 1 再赋值给 `a`。

现在我们再回过头来看 LHS 和 RHS，之前给两种不同的查询方式分别定义为赋值符的左侧查询和右侧查询是不准确的，RHS 的全名为 Rigth Hand Side，意思就是普通的右手边， 但你可以理解为 retrieve his source value，意思为检索它源头的值，这样更方便去理解，而 LHS 理解为赋值这个操作的目标。

### 作用域的嵌套

之前我们所讨论的所有情况都只是基于当前作用域的情况下，但在开发过程中往往是多层作用域相互嵌套存在的，这种存在多层嵌套的作用域又是如何对变量进行操作的呢

```js
var b = 1;

function add() {
  var a = b + 1;
  return a;
}

add();
```

看上面的代码片段，在函数 `add` 中从当前函数的作用域对变量 `b` 进行 RHS 查询，若是在当前作用域无法找到 `b` ，这时引擎就会从上一级的作用域继续对 `b` 进行 RHS 查询，直到查询到了变量 `b` 或是逐层进入到全局作用域依然无法查询到 `b` 变量后便会停止查询。由此可见引擎对变量的查询首先会从当前的作用域开始进行相应的查询，若是在当前作用域无法找到目标变量便会进入到上层作用域继续查询，如此逐层进行查询直到找到目标变量或者已经进入全局作用域依然无法找到目标变量便会抛出异常并结束此次查询操作。

### 函数作用域以及块作用域

之前说到在编码过程中往往是一个全局作用域中嵌套多层作用域，这些作用域可以是函数作用域或是块作用域

#### 函数作用域

相信不难理解函数作用域便是存在于函数内部的作用域

```js
var a = "a";
var c = "c";

function foo(param) {
  var b = "b";
  var c = "cc";
  console.log(param); // "a"
  console.log(c); // "cc"
}

console.log(c); // "c"
console.log(b); // b is not defined

foo(a);
```

分析上面的代码片段中，全局作用域中声明了变量 `a、c` 以及函数 `foo`，在函数 `foo` 的内部包含 `b param`，在执行到第 11 行时会抛出错误 _ReferenceError: b is not defined_ 表示变量 `b` 未被声明无法找到，这说明在 foo 内部声明的变量被绑定在了当前函数的作用域中无法在此作用域的外部被找到，这就好似这些函数内部的变量都被函数本身隐藏了起来，这实际上是个非常有用的功能，函数将内部的变量私有化外部无法访问，防止了过多的变量暴露出去污染全局作用域，这个原则是从 最小特权原则 引申而来，这个原则大致说的是在软件设计时，应当尽可能的减少不必要的变量暴露在外。这样不仅仅是防止了全局作用域的被污染也大大规避了变量名的冲突，上面代码片段中分别声明了两次变量 c 但却是互不影响的，因为在函数内部的变量遮蔽了外部作用域中的同名变量，这也被称作“遮蔽效应”；在之前我们有说到过引擎去作用域中查找目标变量时会首先在当前作用域中进行查询只有在当前作用域中无法找到时才会去到上层作用域中继续查询。

> ReferenceError 在引擎去作用域中进行 RHS 查询且逐层访问到全局作用域依然无法找到目标变量时便会抛出 ReferenceError 异常

#### 块作用域

在 ES6 引入 `let` 与 `const` 关键字之前，我们都是用 `var` 关键字去声明变量，但是除去在函数内声明的变量会被绑定在函数内部的作用域将其从全局作用域隐藏起来，在其他地方使用 `var` 声明变量都会将变量暴露给外部作用域。

```js
try {
  var a = "a";
  function foo() {
    var b = "b";
  }

  bar();
} catch (err) {
  console.log(err); // ReferenceError: bar is not defined
}

console.log(a); // a
console.log(b); // ReferenceError: b is not defined
console.log(err); // ReferenceError: err is not defined
```

看上面的代码片段，在 `try` 关键字的内部声明了 `a` 和 `foo` ，函数 `foo` 内部声明了 `b`，当在外部查询 `a` 时能够取得在 `try` 内部声明的 `a`，但在查询 `b` 时却抛出了 _ReferenceError_ 异常，因为 `b`是在函数内部声明的变量它被绑定到了函数作用域中外部无法查询到 `b`，当使用 `var` 关键字声明变量时最终这个变量都会被暴露给外层作用域，但若是在函数中声明变量则不会有这个问题；另外值得注意的是我们在 `try` 内部的代码块中调用了一个未被声明的函数因此 `catch` 捕获到了异常，`catch` 会创建一个块作用域，将捕获到的异常储存于一个变量中，并将该变量绑定到当前创建的块作用域中，外部无法访问到该变量，但在该块作用域内使用 `var` 声明变量一样会暴露给外部作用域。

---

在 ES6 中引入了两个新的关键字分别问 `const 、let`，通过这个两个关键字创建的变量都会被绑定到当前的作用域中，换句话说使用这两个关键字创建出来的变量你无法在其他作用域中访问

**let**

```js
{
  var a = "a";
  let b = "b";
}
console.log(a); // a
console.log(b); // ReferenceError: b is not defined
```

从上面的代码可以清晰的看出使用 { … } 创建了可用于绑定的块，用 `let` 关键字声明变量 `a` 并将其绑定到当前所处的块中，在块外部是无法访问其内部的使用 `let` 关键字所声明的变量的,但 `a` 因使用 `var` 创建被暴露给外部所以能顺利被找到。

**const**

```js
{
  const a = "a";
  var b = "b";

  a = b; // TypeError: Assignment to constant variable
}
console.log(b); // b
console.log(a): // ReferenceError: a is not defined
```

`const` 关键字与 `let` 的区别在于它所声明的变量的值是无法被改变的（常量），若是对 `const` 关键字声明的常量进行了修改便会抛出 _TypeError_ 异常

> TypeError: 这个异常代表能够从作用域中查询到目标变量，但却对目标变量进行了不正确的操作，例如将变量当成函数去调用或是尝试改变常量的值等
